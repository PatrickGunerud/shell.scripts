#!/usr/bin/env bash
set -euo pipefail

# git-ai-commit: DevSecOps-minded commit message generator for STAGED changes
#
# Backend selection:
#   AI_BACKEND=codex|claude   (default: codex)
#
# Backend env:
#   Codex:
#     CODEX_CMD   (default: codex)
#     CODEX_ARGS  (default: exec --color never -)
#   Claude (Anthropic CLI):
#     CLAUDE_CMD  (default: claude)
#     CLAUDE_ARGS (default: -p)   # reads prompt from stdin; prints completion to stdout
#
# Behavior:
# - If NO staged changes:
#     - Warns clearly
#     - If there are working-tree changes, offers to "git add -A" (with confirmation)
#     - Then proceeds (or exits if declined)
# - If staged changes exist:
#     - Proceeds normally
# - Generates a commit message for STAGED changes.
# - Shows it with separators (colorized if TTY).
# - Prompts for confirmation, then runs: git commit -F - (optionally --no-verify).
#
# Requirements:
# - jq is required (always), per your request.
#
# Notes:
# - Cleans tool output (removes "tokens used" footer, repeats, and rollback section if emitted).
# - In --json mode, prints raw JSON only (no separators) and does NOT auto-commit.

AI_BACKEND="${AI_BACKEND:-codex}"

CODEX_CMD="${CODEX_CMD:-codex}"
CODEX_ARGS="${CODEX_ARGS:-exec --color never -}"
CLAUDE_CMD="${CLAUDE_CMD:-claude}"
CLAUDE_ARGS="${CLAUDE_ARGS:--p}"

AI_MAX_CHARS="${AI_MAX_CHARS:-120000}"

die() { echo "ERROR: $*" >&2; exit 1; }

install_help_jq() {
  cat >&2 <<'EOF'
jq is required.

Install examples:
  macOS (Homebrew):    brew install jq
  macOS (MacPorts):    sudo port install jq
  Debian/Ubuntu:       sudo apt-get update && sudo apt-get install -y jq
  Fedora:              sudo dnf install -y jq
  RHEL/CentOS:         sudo yum install -y jq   (or dnf on newer)
  Arch:                sudo pacman -S --noconfirm jq
  Alpine:              sudo apk add jq
EOF
}

require_cmd() {
  local cmd="$1"
  command -v "$cmd" >/dev/null 2>&1 || {
    echo "ERROR: Required command not found: $cmd" >&2
    echo "" >&2
    if [[ "$cmd" == "jq" ]]; then
      install_help_jq
    else
      echo "Install it using your platform's package manager." >&2
    fi
    exit 127
  }
}

truncate() {
  local s="$1"
  if (( ${#s} > AI_MAX_CHARS )); then
    printf "%s\n\n[TRUNCATED to %s chars]\n" "${s:0:AI_MAX_CHARS}" "$AI_MAX_CHARS"
  else
    printf "%s\n" "$s"
  fi
}

usage() {
  cat <<EOF
git ai-commit [--full] [--json] [--no-verify] [--no-commit] [--yes]

Generates a DevSecOps-minded commit message for changes.

Backends:
  AI_BACKEND=codex   Uses: \$CODEX_CMD \$CODEX_ARGS
  AI_BACKEND=claude  Uses: \$CLAUDE_CMD \$CLAUDE_ARGS

Options:
  --full        Add extra DevSecOps checklist questions
  --json        Request JSON output (requires jq; validates output). Does NOT auto-commit.
  --no-verify   Pass --no-verify to git commit
  --no-commit   Do not run git commit (print only)
  --yes         Skip commit confirmation prompt (still may prompt to stage if nothing staged)
  -h, --help    Show help
EOF
}

# ---------- TTY colors (only when stdout is a TTY and tput works) ----------
is_tty() { [[ -t 1 ]]; }
tput_ok() { command -v tput >/dev/null 2>&1 && tput sgr0 >/dev/null 2>&1; }

COLOR_ON=0
if is_tty && tput_ok; then
  COLOR_ON=1
fi

c() { # c <tput-seq> <text>
  local seq="$1"; shift
  if (( COLOR_ON == 1 )); then
    printf "%s%s%s" "$(tput ${seq})" "$*" "$(tput sgr0)"
  else
    printf "%s" "$*"
  fi
}

print_commit_block() {
  local content="$1"
  local line="────────────────────────────────────────────────────────────"
  local title="AI-Generated Commit Message"
  local meta="Backend: ${AI_BACKEND}"

  if (( COLOR_ON == 1 )); then
    printf "%s\n" "$(c 'setaf 4' "$line")"
    printf "%s\n" "$(c 'bold' "$title")"
    printf "%s\n" "$(c 'setaf 8' "$meta")"
    printf "%s\n\n" "$(c 'setaf 4' "$line")"
  else
    printf "%s\n%s\n%s\n%s\n\n" "$line" "$title" "$meta" "$line"
  fi

  printf "%s\n\n" "$content"

  if (( COLOR_ON == 1 )); then
    printf "%s\n" "$(c 'setaf 4' "$line")"
  else
    printf "%s\n" "$line"
  fi
}

confirm_yn() {
  local prompt="$1"
  local reply=""
  if [[ -t 0 ]]; then
    read -r -p "$prompt" reply || true
    [[ "$reply" == "y" || "$reply" == "Y" ]]
  else
    return 1
  fi
}

confirm_commit() {
  confirm_yn "Commit with the message above? [y/N] "
}

# ---------- AI runner ----------
run_ai() {
  local prompt="$1"
  case "$AI_BACKEND" in
    codex)
      require_cmd "$CODEX_CMD"
      # shellcheck disable=SC2086
      printf "%s" "$prompt" | "$CODEX_CMD" $CODEX_ARGS
      ;;
    claude)
      require_cmd "$CLAUDE_CMD"
      # shellcheck disable=SC2086
      printf "%s" "$prompt" | "$CLAUDE_CMD" $CLAUDE_ARGS
      ;;
    *)
      die "Unsupported AI_BACKEND='$AI_BACKEND' (expected 'codex' or 'claude')"
      ;;
  esac
}

# Clean up tool output:
# - Drop leading banner line exactly "codex"/"claude"
# - Drop everything after first "tokens used" marker (case-insensitive)
# - Drop everything after "Rollback/Operational Notes:" if it appears
clean_ai_output() {
  local raw="$1"
  awk '
    BEGIN { drop=0; line=0 }
    {
      line++
      s=$0

      if (line==1) {
        t=s
        gsub(/^[[:space:]]+|[[:space:]]+$/, "", t)
        if (tolower(t)=="codex" || tolower(t)=="claude") next
      }

      t=s
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", t)
      tl=tolower(t)

      if (tl ~ /tokens[[:space:]]+used/) drop=1
      if (tl ~ /^rollback\/operational[[:space:]]+notes:/) drop=1

      if (!drop) print $0
    }
  ' <<<"$raw"
}

# ---------- flags ----------
FULL=0
JSON_OUT=0
NO_VERIFY=0
NO_COMMIT=0
YES=0

while (( $# > 0 )); do
  case "$1" in
    --full) FULL=1; shift ;;
    --json) JSON_OUT=1; shift ;;
    --no-verify) NO_VERIFY=1; shift ;;
    --no-commit) NO_COMMIT=1; shift ;;
    --yes) YES=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) die "Unknown arg: $1" ;;
  esac
done

git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not in a git repo."

# Always require jq (per your request)
require_cmd jq

# If nothing staged, offer to stage changes
if git diff --cached --quiet; then
  echo "WARNING: No staged changes detected." >&2

  if git status --porcelain=v1 | grep -q .; then
    # There are some changes (staged or unstaged) in the repo; since cached is empty, they are unstaged/untracked
    echo "You have working-tree changes, but nothing is staged." >&2

    if (( YES == 1 )); then
      echo "Auto-staging all changes due to --yes: git add -A" >&2
      git add -A
    else
      if confirm_yn "Stage ALL changes with 'git add -A' now? [y/N] "; then
        git add -A
      else
        die "Nothing staged. Stage changes (e.g., 'git add -A') and re-run."
      fi
    fi
  else
    die "No changes detected. Nothing to commit."
  fi
fi

# Ensure now we have something staged (after optional staging)
git diff --cached --quiet && die "Still no staged changes. Nothing to do."

STATUS="$(git status --porcelain=v1 2>/dev/null || true)"
STAGED_FILES="$(git diff --cached --name-status 2>/dev/null || true)"
DIFF="$(git diff --cached --patch 2>/dev/null || true)"

POTENTIAL_SECRETS="$( (git diff --cached | grep -E -i 'apikey|api_key|secret|token|password|private_key|BEGIN (RSA|OPENSSH) PRIVATE KEY' || true) | head -n 20 )"
PERMISSIONS_HINTS="$( (git diff --cached | grep -E -i 'iam:|policy|role|rbac|clusterrole|serviceaccount|assumeRole|oidc|permissions' || true) | head -n 40 )"

EXTRA_CHECKLIST=""
if (( FULL == 1 )); then
  EXTRA_CHECKLIST=$'
Extra DevSecOps checklist (answer only when evidence exists in the diff):
- AuthN/AuthZ changes? least privilege preserved?
- Secrets: any new secret handling? ensure no hardcoded creds.
- Supply chain: dependency bumps? lockfile changes? provenance?
- CI/CD: pipeline changes? pin versions/SHAs?
- IaC/config: blast radius?
- Logging/PII risk? audit trails?
- Network exposure? ports/TLS changes?
'
fi

OUTPUT_FORMAT_TEXT=$'Output format:\n- First line: Conventional Commit subject (<=72 chars)\n- Blank line\n- Bullets summarizing changes\n- Blank line\n- "Security/DevSecOps Impact:" section (bullets)\n- "Testing:" section (bullets)\n'

OUTPUT_FORMAT_JSON=$'Output format (JSON only, no markdown, no commentary, no code fences):\n{\n  "subject": "type(scope): subject <= 72 chars",\n  "summary_bullets": ["..."],\n  "security_devsecops_impact": ["..."],\n  "testing": ["..."]\n}\nRules:\n- JSON must be valid.\n- Arrays must contain strings only.\n- Do not invent changes not present in the diff.\n- If you cannot substantiate a security claim from the diff, write \"No evidence in diff\".\n'

PROMPT="$(cat <<EOF
Task:
Create a single high-quality *git commit message* for the currently STAGED changes with a DevSecOps mindset.

Context:
- Repo: $(basename "$(git rev-parse --show-toplevel)")
- Branch: $(git rev-parse --abbrev-ref HEAD)

Core requirements:
- Use Conventional Commits: type(scope): subject
- Subject <= 72 chars (no trailing period)
- Body: bullet summary of meaningful changes (group by area if helpful)
- Include sections:
  - Security/DevSecOps Impact:
  - Testing:
- Do not invent changes not present in the diff
- If you cannot substantiate a security claim from the diff, say "No evidence in diff" rather than guessing

Working Tree Status:
${STATUS:-<unknown>}

Staged files (name-status):
${STAGED_FILES:-<none>}

Potential secret matches:
${POTENTIAL_SECRETS:-<none>}

Permissions/IAM/RBAC hints:
${PERMISSIONS_HINTS:-<none>}

Staged unified diff:
$(truncate "${DIFF:-<none>}")

${EXTRA_CHECKLIST}
$(
  if (( JSON_OUT == 1 )); then
    printf "%s" "$OUTPUT_FORMAT_JSON"
  else
    printf "%s" "$OUTPUT_FORMAT_TEXT"
  fi
)
EOF
)"

RAW_OUTPUT="$(run_ai "$PROMPT")"
CLEAN_OUTPUT="$(clean_ai_output "$RAW_OUTPUT")"
CLEAN_OUTPUT="$(perl -0777 -pe 's/\s+\z/\n/s' <<<"$CLEAN_OUTPUT")"

# JSON mode: validate, print JSON only, no auto-commit
if (( JSON_OUT == 1 )); then
  printf "%s" "$CLEAN_OUTPUT" | jq -e . >/dev/null 2>&1 || {
    echo "ERROR: AI output was not valid JSON." >&2
    echo "----- BEGIN RAW OUTPUT -----" >&2
    printf "%s\n" "$RAW_OUTPUT" >&2
    echo "----- END RAW OUTPUT -----" >&2
    exit 1
  }
  printf "%s\n" "$CLEAN_OUTPUT"
  exit 0
fi

# Human-readable view
print_commit_block "$CLEAN_OUTPUT"

# Print-only mode
if (( NO_COMMIT == 1 )); then
  exit 0
fi

# Commit confirmation
if (( YES == 0 )); then
  if ! confirm_commit; then
    echo "Aborted (no commit created)." >&2
    exit 1
  fi
fi

# Auto-run git commit with the clean message (NO separators)
GIT_ARGS=(commit -F -)
if (( NO_VERIFY == 1 )); then
  GIT_ARGS+=(--no-verify)
fi

printf "%s" "$CLEAN_OUTPUT" | git "${GIT_ARGS[@]}"
