#!/usr/bin/env bash
set -euo pipefail

# git-ai-commit: DevSecOps-minded commit message generator for STAGED changes
#
# Model backend selection:
#   AI_BACKEND=codex|claude   (default: codex)
#
# Backend env:
#   Codex:
#     CODEX_CMD   (default: codex)
#     CODEX_ARGS  (default: exec --color never -)
#   Claude (Anthropic CLI):
#     CLAUDE_CMD  (default: claude)
#     CLAUDE_ARGS (default: -p)   # reads prompt from stdin; prints completion to stdout

AI_BACKEND="${AI_BACKEND:-codex}"

CODEX_CMD="${CODEX_CMD:-codex}"
CODEX_ARGS="${CODEX_ARGS:-exec --color never -}"
CLAUDE_CMD="${CLAUDE_CMD:-claude}"
CLAUDE_ARGS="${CLAUDE_ARGS:--p}"

AI_MAX_CHARS="${AI_MAX_CHARS:-120000}"

die() { echo "ERROR: $*" >&2; exit 1; }

install_help_jq() {
  cat >&2 <<'EOF'
jq is required.

Install examples:
  macOS (Homebrew):    brew install jq
  macOS (MacPorts):    sudo port install jq
  Debian/Ubuntu:       sudo apt-get update && sudo apt-get install -y jq
  Fedora:              sudo dnf install -y jq
  RHEL/CentOS:         sudo yum install -y jq   (or dnf on newer)
  Arch:                sudo pacman -S --noconfirm jq
  Alpine:              sudo apk add jq
EOF
}

require_cmd() {
  local cmd="$1"
  command -v "$cmd" >/dev/null 2>&1 || {
    echo "ERROR: Required command not found: $cmd" >&2
    echo "" >&2
    if [[ "$cmd" == "jq" ]]; then
      install_help_jq
    else
      echo "Install it using your platform's package manager." >&2
    fi
    exit 127
  }
}

truncate() {
  local s="$1"
  if (( ${#s} > AI_MAX_CHARS )); then
    printf "%s\n\n[TRUNCATED to %s chars]\n" "${s:0:AI_MAX_CHARS}" "$AI_MAX_CHARS"
  else
    printf "%s\n" "$s"
  fi
}

usage() {
  cat <<EOF
git ai-commit [--full] [--json] [--no-verify]

Backends:
  AI_BACKEND=codex   Uses: \$CODEX_CMD \$CODEX_ARGS
  AI_BACKEND=claude  Uses: \$CLAUDE_CMD \$CLAUDE_ARGS

Options:
  --full        Add extra DevSecOps checklist questions
  --json        Request JSON output (requires jq; validates output)
  --no-verify   Pass --no-verify to git commit
EOF
}

# Run selected backend with prompt on stdin; write response to stdout.
run_ai() {
  local prompt="$1"

  case "$AI_BACKEND" in
    codex)
      require_cmd "$CODEX_CMD"
      # shellcheck disable=SC2086
      printf "%s" "$prompt" | "$CODEX_CMD" $CODEX_ARGS
      ;;
    claude)
      require_cmd "$CLAUDE_CMD"
      # shellcheck disable=SC2086
      printf "%s" "$prompt" | "$CLAUDE_CMD" $CLAUDE_ARGS
      ;;
    *)
      die "Unsupported AI_BACKEND='$AI_BACKEND' (expected 'codex' or 'claude')"
      ;;
  esac
}

FULL=0
JSON_OUT=0
NO_VERIFY=0

while (( $# > 0 )); do
  case "$1" in
    --full) FULL=1; shift ;;
    --json) JSON_OUT=1; shift ;;
    --no-verify) NO_VERIFY=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) die "Unknown arg: $1" ;;
  esac
done

git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not in a git repo."

# Always require jq (per your request)
require_cmd jq

git diff --cached --quiet && die "No staged changes. Stage files first (git add ...)."

STATUS="$(git status --porcelain=v1 2>/dev/null || true)"
STAGED_FILES="$(git diff --cached --name-status 2>/dev/null || true)"
DIFF="$(git diff --cached --patch 2>/dev/null || true)"

POTENTIAL_SECRETS="$( (git diff --cached | grep -E -i 'apikey|api_key|secret|token|password|private_key|BEGIN (RSA|OPENSSH) PRIVATE KEY' || true) | head -n 20 )"
PERMISSIONS_HINTS="$( (git diff --cached | grep -E -i 'iam:|policy|role|rbac|clusterrole|serviceaccount|assumeRole|oidc|permissions' || true) | head -n 40 )"

EXTRA_CHECKLIST=""
if (( FULL == 1 )); then
  EXTRA_CHECKLIST=$'
Extra DevSecOps checklist (answer only when evidence exists in the diff):
- AuthN/AuthZ changes? least privilege preserved?
- Secrets: any new secret handling? ensure no hardcoded creds.
- Supply chain: dependency bumps? lockfile changes? provenance?
- CI/CD: pipeline changes? pin versions/SHAs?
- IaC/config: blast radius? rollback plan?
- Logging/PII risk? audit trails?
- Network exposure? ports/TLS changes?
'
fi

OUTPUT_FORMAT_TEXT=$'Output format:\n- First line: Conventional Commit subject (<=72 chars)\n- Blank line\n- Bullets summarizing changes\n- Blank line\n- "Security/DevSecOps Impact:" section (bullets)\n- "Testing:" section (bullets)\n'

OUTPUT_FORMAT_JSON=$'Output format (JSON only, no markdown, no commentary, no code fences):\n{\n  "subject": "type(scope): subject <= 72 chars",\n  "summary_bullets": ["..."],\n  "security_devsecops_impact": ["..."],\n  "testing": ["..."]\n}\nRules:\n- JSON must be valid.\n- Arrays must contain strings only.\n- Do not invent changes not present in the diff.\n- If you cannot substantiate a security claim from the diff, write \"No evidence in diff\".\n'

PROMPT="$(cat <<EOF
Task:
Create a single high-quality *git commit message* for the currently STAGED changes with a DevSecOps mindset.

Context:
- Repo: $(basename "$(git rev-parse --show-toplevel)")
- Branch: $(git rev-parse --abbrev-ref HEAD)

Core requirements:
- Use Conventional Commits: type(scope): subject
- Subject <= 72 chars (no trailing period)
- Body: bullet summary of meaningful changes (group by area if helpful)
- Include sections:
  - Security/DevSecOps Impact:
  - Testing:
- Do not invent changes not present in the diff
- If you cannot substantiate a security claim from the diff, say "No evidence in diff" rather than guessing

Working Tree Status:
${STATUS:-<unknown>}

Staged files (name-status):
${STAGED_FILES:-<none>}

Potential secret matches:
${POTENTIAL_SECRETS:-<none>}

Permissions/IAM/RBAC hints:
${PERMISSIONS_HINTS:-<none>}

Staged unified diff:
$(truncate "${DIFF:-<none>}")

${EXTRA_CHECKLIST}
$(
  if (( JSON_OUT == 1 )); then
    printf "%s" "$OUTPUT_FORMAT_JSON"
  else
    printf "%s" "$OUTPUT_FORMAT_TEXT"
  fi
)
EOF
)"

RAW_OUTPUT="$(run_ai "$PROMPT")"

CLEAN_OUTPUT="$(
  awk '
    BEGIN {drop_tokens=0; drop_rollback=0}
    /^[[:space:]]*tokens used[[:space:]]*$/ {drop_tokens=1}
    /^[[:space:]]*Rollback\/Operational Notes:[[:space:]]*$/ {drop_rollback=1}
    (drop_tokens==0 && drop_rollback==0) {print}
  ' <<<"$RAW_OUTPUT"
)"

CLEAN_OUTPUT="$(
  perl -0777 -pe 's/\s+\z/\n/s' <<<"$CLEAN_OUTPUT"
)"

if (( JSON_OUT == 1 )); then
  printf "%s" "$CLEAN_OUTPUT" | jq -e . >/dev/null 2>&1 || {
    echo "ERROR: AI output was not valid JSON." >&2
    echo "----- BEGIN RAW OUTPUT -----" >&2
    printf "%s\n" "$RAW_OUTPUT" >&2
    echo "----- END RAW OUTPUT -----" >&2
    exit 1
  }
fi

printf "%s\n" "$CLEAN_OUTPUT"
