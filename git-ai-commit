#!/usr/bin/env bash
set -euo pipefail

# git-ai-commit: DevSecOps-minded commit message generator for STAGED changes

CODEX_CMD="${CODEX_CMD:-codex}"
CODEX_ARGS="${CODEX_ARGS:-exec --color never -}"
AI_MAX_CHARS="${AI_MAX_CHARS:-120000}"

die() { echo "ERROR: $*" >&2; exit 1; }

install_help_jq() {
  cat >&2 <<'EOF'
jq is required.

Install examples:
  macOS (Homebrew):    brew install jq
  macOS (MacPorts):    sudo port install jq
  Debian/Ubuntu:       sudo apt-get update && sudo apt-get install -y jq
  Fedora:              sudo dnf install -y jq
  RHEL/CentOS:         sudo yum install -y jq   (or dnf on newer)
  Arch:                sudo pacman -S --noconfirm jq
  Alpine:              sudo apk add jq
EOF
}

require_cmd() {
  local cmd="$1"
  command -v "$cmd" >/dev/null 2>&1 || {
    echo "ERROR: Required command not found: $cmd" >&2
    echo "" >&2
    if [[ "$cmd" == "jq" ]]; then
      install_help_jq
    else
      echo "Install it using your platform's package manager." >&2
    fi
    exit 127
  }
}

truncate() {
  local s="$1"
  if (( ${#s} > AI_MAX_CHARS )); then
    printf "%s\n\n[TRUNCATED to %s chars]\n" "${s:0:AI_MAX_CHARS}" "$AI_MAX_CHARS"
  else
    printf "%s\n" "$s"
  fi
}

usage() {
  cat <<EOF
git ai-commit [--full] [--json] [--no-verify]

Generates a DevSecOps-minded commit message for STAGED changes.

Options:
  --full        Add extra DevSecOps checklist questions
  --json        Request JSON output from Codex (validates with jq)
  --no-verify   Pass --no-verify to git commit
EOF
}

FULL=0
JSON_OUT=0
NO_VERIFY=0

while (( $# > 0 )); do
  case "$1" in
    --full) FULL=1; shift ;;
    --json) JSON_OUT=1; shift ;;
    --no-verify) NO_VERIFY=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) die "Unknown arg: $1" ;;
  esac
done

git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not in a git repo."

# Always require jq (per your request)
require_cmd jq
require_cmd "$CODEX_CMD"

git diff --cached --quiet && die "No staged changes. Stage files first (git add ...)."

STATUS="$(git status --porcelain=v1 2>/dev/null || true)"
STAGED_FILES="$(git diff --cached --name-status 2>/dev/null || true)"
DIFF="$(git diff --cached --patch 2>/dev/null || true)"

POTENTIAL_SECRETS="$( (git diff --cached | grep -E -i 'apikey|api_key|secret|token|password|private_key|BEGIN (RSA|OPENSSH) PRIVATE KEY' || true) | head -n 20 )"
PERMISSIONS_HINTS="$( (git diff --cached | grep -E -i 'iam:|policy|role|rbac|clusterrole|serviceaccount|assumeRole|oidc|permissions' || true) | head -n 40 )"

EXTRA_CHECKLIST=""
if (( FULL == 1 )); then
  EXTRA_CHECKLIST=$'
Extra DevSecOps checklist (answer only when evidence exists in the diff):
- AuthN/AuthZ changes? least privilege preserved?
- Secrets: any new secret handling? ensure no hardcoded creds.
- Supply chain: dependency bumps? lockfile changes? provenance?
- CI/CD: pipeline changes? pin versions/SHAs?
- IaC/config: blast radius? rollback plan?
- Logging/PII risk? audit trails?
- Network exposure? ports/TLS changes?
'
fi

OUTPUT_FORMAT_TEXT=$'Output format:\n- First line: Conventional Commit subject (<=72 chars)\n- Blank line\n- Bullets summarizing changes\n- Blank line\n- "Security/DevSecOps Impact:" section (bullets)\n- "Testing:" section (bullets)\n'

OUTPUT_FORMAT_JSON=$'Output format (JSON only, no markdown, no commentary, no code fences):\n{\n  "subject": "type(scope): subject <= 72 chars",\n  "summary_bullets": ["..."],\n  "security_devsecops_impact": ["..."],\n  "testing": ["..."]\n}\nRules:\n- JSON must be valid.\n- Arrays must contain strings only.\n- Do not invent changes not present in the diff.\n- If you cannot substantiate a security claim from the diff, write \"No evidence in diff\".\n'

PROMPT="$(cat <<EOF
Task:
Create a single high-quality *git commit message* for the currently STAGED changes with a DevSecOps mindset.

Context:
- Repo: $(basename "$(git rev-parse --show-toplevel)")
- Branch: $(git rev-parse --abbrev-ref HEAD)

Core requirements:
- Use Conventional Commits: type(scope): subject
- Subject <= 72 chars (no trailing period)
- Body: bullet summary of meaningful changes (group by area if helpful)
- Include sections:
  - Security/DevSecOps Impact:
  - Testing:
- Do not invent changes not present in the diff
- If you cannot substantiate a security claim from the diff, say "No evidence in diff" rather than guessing

Working Tree Status:
${STATUS:-<unknown>}

Staged files (name-status):
${STAGED_FILES:-<none>}

Potential secret matches:
${POTENTIAL_SECRETS:-<none>}

Permissions/IAM/RBAC hints:
${PERMISSIONS_HINTS:-<none>}

Staged unified diff:
$(truncate "${DIFF:-<none>}")

${EXTRA_CHECKLIST}
$(
  if (( JSON_OUT == 1 )); then
    printf "%s" "$OUTPUT_FORMAT_JSON"
  else
    printf "%s" "$OUTPUT_FORMAT_TEXT"
  fi
)
EOF
)"

# shellcheck disable=SC2086
RAW_OUTPUT="$(printf "%s" "$PROMPT" | "$CODEX_CMD" $CODEX_ARGS)"

CLEAN_OUTPUT="$(
  awk '
    BEGIN {drop_tokens=0; drop_rollback=0}
    /^[[:space:]]*tokens used[[:space:]]*$/ {drop_tokens=1}
    /^[[:space:]]*Rollback\/Operational Notes:[[:space:]]*$/ {drop_rollback=1}
    (drop_tokens==0 && drop_rollback==0) {print}
  ' <<<"$RAW_OUTPUT"
)"

CLEAN_OUTPUT="$(
  perl -0777 -pe 's/\s+\z/\n/s' <<<"$CLEAN_OUTPUT"
)"

if (( JSON_OUT == 1 )); then
  printf "%s" "$CLEAN_OUTPUT" | jq -e . >/dev/null 2>&1 || {
    echo "ERROR: Codex output was not valid JSON." >&2
    echo "----- BEGIN RAW OUTPUT -----" >&2
    printf "%s\n" "$RAW_OUTPUT" >&2
    echo "----- END RAW OUTPUT -----" >&2
    exit 1
  }
fi

printf "%s\n" "$CLEAN_OUTPUT"
