#!/usr/bin/env bash
set -euo pipefail

# git-ai-commit: DevSecOps-minded commit message generator for STAGED changes
#
# Backend selection:
#   AI_BACKEND=codex|claude   (default: codex)
#
# Backend env:
#   Codex:
#     CODEX_CMD   (default: codex)
#     CODEX_ARGS  (default: exec --color never -)
#   Claude (Anthropic CLI):
#     CLAUDE_CMD  (default: claude)
#     CLAUDE_ARGS (default: -p)   # reads prompt from stdin; prints completion to stdout
#
# Behavior:
# - If NO staged changes:
#     - Warns clearly
#     - If there are working-tree changes, offers to "git add -A" (with confirmation)
#     - Then proceeds (or exits if declined)
# - If staged changes exist:
#     - Proceeds normally
# - Generates a commit message for STAGED changes.
# - Shows it with separators (colorized if TTY).
# - Prompts for confirmation, then runs: git commit -F - (optionally --no-verify).
#
# Requirements:
# - jq is required (always), per your request.
#
# Notes:
# - Cleans tool output (removes "tokens used" footer, repeats, and rollback section if emitted).
# - In --json mode, prints raw JSON only (no separators) and does NOT auto-commit.

source "$(dirname "$0")/lib/git-ai-common.sh"

usage() {
  cat <<EOF
git ai-commit [--full] [--json] [--no-verify] [--no-commit] [--yes]

Generates a DevSecOps-minded commit message for changes.

Backends:
  AI_BACKEND=codex   Uses: \$CODEX_CMD \$CODEX_ARGS
  AI_BACKEND=claude  Uses: \$CLAUDE_CMD \$CLAUDE_ARGS

Options:
  --full        Add extra DevSecOps checklist questions
  --json        Request JSON output (requires jq; validates output). Does NOT auto-commit.
  --no-verify   Pass --no-verify to git commit
  --no-commit   Do not run git commit (print only)
  --yes         Skip commit confirmation prompt (still may prompt to stage if nothing staged)
  -h, --help    Show help
EOF
}

print_commit_block() {
  local content="$1"
  local line="────────────────────────────────────────────────────────────"
  local title="AI-Generated Commit Message"
  local meta="Backend: ${AI_BACKEND}"

  if (( COLOR_ON == 1 )); then
    printf "%s\n" "$(c 'setaf 4' "$line")"
    printf "%s\n" "$(c 'bold' "$title")"
    printf "%s\n" "$(c 'setaf 8' "$meta")"
    printf "%s\n\n" "$(c 'setaf 4' "$line")"
  else
    printf "%s\n%s\n%s\n%s\n\n" "$line" "$title" "$meta" "$line"
  fi

  printf "%s\n\n" "$content"

  if (( COLOR_ON == 1 )); then
    printf "%s\n" "$(c 'setaf 4' "$line")"
  else
    printf "%s\n" "$line"
  fi
}

confirm_yn() {
  local prompt="$1"
  local reply=""
  if [[ -t 0 ]]; then
    read -r -p "$prompt" reply || true
    [[ "$reply" == "y" || "$reply" == "Y" ]]
  else
    return 1
  fi
}

confirm_commit() {
  confirm_yn "Commit with the message above? [y/N] "
}

# ---------- flags ----------
FULL=0
JSON_OUT=0
NO_VERIFY=0
NO_COMMIT=0
YES=0

while (( $# > 0 )); do
  case "$1" in
    --full) FULL=1; shift ;;
    --json) JSON_OUT=1; shift ;;
    --no-verify) NO_VERIFY=1; shift ;;
    --no-commit) NO_COMMIT=1; shift ;;
    --yes) YES=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) die "Unknown arg: $1" ;;
  esac
done

git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not in a git repo."

preflight_check git jq grep head perl awk

QUIET=$JSON_OUT

# Determine AI command for display
case "$AI_BACKEND" in
  codex)  _AI_CMD="$CODEX_CMD $CODEX_ARGS" ;;
  claude) _AI_CMD="$CLAUDE_CMD $CLAUDE_ARGS" ;;
  *)      _AI_CMD="(unknown)" ;;
esac

# Print config summary (suppressed in --json mode)
if (( ! QUIET )); then
  _flags=""
  (( FULL ))      && _flags+=" --full"
  (( NO_VERIFY )) && _flags+=" --no-verify"
  (( NO_COMMIT )) && _flags+=" --no-commit"
  (( YES ))       && _flags+=" --yes"
  _flags="${_flags# }"  # trim leading space

  step "── git-ai-commit ──"
  info "Backend:   ${AI_BACKEND}"
  info "Command:   ${_AI_CMD}"
  info "Max chars: ${AI_MAX_CHARS}"
  [[ -n "$_flags" ]] && info "Flags:     ${_flags}"
  echo >&2
fi

(( QUIET )) || step "[1/5] Checking for staged changes..."

# If nothing staged, offer to stage changes
if git diff --cached --quiet; then
  echo "WARNING: No staged changes detected." >&2

  if git status --porcelain=v1 | grep -q .; then
    # There are some changes (staged or unstaged) in the repo; since cached is empty, they are unstaged/untracked
    echo "You have working-tree changes, but nothing is staged." >&2

    if (( YES == 1 )); then
      echo "Auto-staging all changes due to --yes: git add -A" >&2
      git add -A
    else
      if confirm_yn "Stage ALL changes with 'git add -A' now? [y/N] "; then
        git add -A
      else
        die "Nothing staged. Stage changes (e.g., 'git add -A') and re-run."
      fi
    fi
  else
    die "No changes detected. Nothing to commit."
  fi
fi

# Ensure now we have something staged (after optional staging)
git diff --cached --quiet && die "Still no staged changes. Nothing to do."

STATUS="$(git status --porcelain=v1 2>/dev/null || true)"
STAGED_FILES="$(git diff --cached --name-status 2>/dev/null || true)"
DIFF="$(git diff --cached --patch 2>/dev/null || true)"

(( QUIET )) || step "[2/5] Scanning diff for secrets & permission hints..."

POTENTIAL_SECRETS="$( (git diff --cached | grep -E -i 'apikey|api_key|secret|token|password|private_key|BEGIN (RSA|OPENSSH) PRIVATE KEY' || true) | head -n 20 )"
PERMISSIONS_HINTS="$( (git diff --cached | grep -E -i 'iam:|policy|role|rbac|clusterrole|serviceaccount|assumeRole|oidc|permissions' || true) | head -n 40 )"

EXTRA_CHECKLIST=""
if (( FULL == 1 )); then
  EXTRA_CHECKLIST=$'
Extra DevSecOps checklist (answer only when evidence exists in the diff):
- AuthN/AuthZ changes? least privilege preserved?
- Secrets: any new secret handling? ensure no hardcoded creds.
- Supply chain: dependency bumps? lockfile changes? provenance?
- CI/CD: pipeline changes? pin versions/SHAs?
- IaC/config: blast radius?
- Logging/PII risk? audit trails?
- Network exposure? ports/TLS changes?
'
fi

OUTPUT_FORMAT_TEXT=$'Output format:\n- First line: Conventional Commit subject (<=72 chars)\n- Blank line\n- Bullets summarizing changes\n- Blank line\n- "Security/DevSecOps Impact:" section (bullets)\n- "Testing:" section (bullets)\n'

OUTPUT_FORMAT_JSON=$'Output format (JSON only, no markdown, no commentary, no code fences):\n{\n  "subject": "type(scope): subject <= 72 chars",\n  "summary_bullets": ["..."],\n  "security_devsecops_impact": ["..."],\n  "testing": ["..."]\n}\nRules:\n- JSON must be valid.\n- Arrays must contain strings only.\n- Do not invent changes not present in the diff.\n- If you cannot substantiate a security claim from the diff, write \"No evidence in diff\".\n'

(( QUIET )) || step "[3/5] Building prompt..."

PROMPT="$(cat <<EOF
Task:
Create a single high-quality *git commit message* for the currently STAGED changes with a DevSecOps mindset.

Context:
- Repo: $(basename "$(git rev-parse --show-toplevel)")
- Branch: $(git rev-parse --abbrev-ref HEAD)

Core requirements:
- Use Conventional Commits: type(scope): subject
- Subject <= 72 chars (no trailing period)
- Body: bullet summary of meaningful changes (group by area if helpful)
- Include sections:
  - Security/DevSecOps Impact:
  - Testing:
- Do not invent changes not present in the diff
- If you cannot substantiate a security claim from the diff, say "No evidence in diff" rather than guessing

Working Tree Status:
${STATUS:-<unknown>}

Staged files (name-status):
${STAGED_FILES:-<none>}

Potential secret matches:
${POTENTIAL_SECRETS:-<none>}

Permissions/IAM/RBAC hints:
${PERMISSIONS_HINTS:-<none>}

Staged unified diff:
$(truncate "${DIFF:-<none>}")

${EXTRA_CHECKLIST}
$(
  if (( JSON_OUT == 1 )); then
    printf "%s" "$OUTPUT_FORMAT_JSON"
  else
    printf "%s" "$OUTPUT_FORMAT_TEXT"
  fi
)
EOF
)"

(( QUIET )) || step "[4/5] Calling AI backend (${AI_BACKEND})..."

RAW_OUTPUT="$(run_ai "$PROMPT")"
CLEAN_OUTPUT="$(clean_ai_output "$RAW_OUTPUT")"

# JSON mode: validate, print JSON only, no auto-commit
if (( JSON_OUT == 1 )); then
  printf "%s" "$CLEAN_OUTPUT" | jq -e . >/dev/null 2>&1 || {
    echo "ERROR: AI output was not valid JSON." >&2
    echo "----- BEGIN RAW OUTPUT -----" >&2
    printf "%s\n" "$RAW_OUTPUT" >&2
    echo "----- END RAW OUTPUT -----" >&2
    exit 1
  }
  printf "%s\n" "$CLEAN_OUTPUT"
  exit 0
fi

(( QUIET )) || step "[5/5] Done."

# Human-readable view
print_commit_block "$CLEAN_OUTPUT"

# Print-only mode
if (( NO_COMMIT == 1 )); then
  exit 0
fi

# Commit confirmation
if (( YES == 0 )); then
  if ! confirm_commit; then
    echo "Aborted (no commit created)." >&2
    exit 1
  fi
fi

# Auto-run git commit with the clean message (NO separators)
GIT_ARGS=(commit -F -)
if (( NO_VERIFY == 1 )); then
  GIT_ARGS+=(--no-verify)
fi

printf "%s" "$CLEAN_OUTPUT" | git "${GIT_ARGS[@]}"
