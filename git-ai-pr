#!/usr/bin/env bash
set -euo pipefail

# git-ai-pr: DevSecOps-minded squash PR summary + (optional) auto-create GitHub PR as DRAFT via gh
#
# Pattern 3 wrapper:
# - If stdin is piped, uses that as diff/input body (instead of collecting diff)
# - Otherwise collects commits + diff vs base
#
# Usage:
#   git ai-pr
#   git ai-pr --base origin/main
#   git ai-pr --create-draft              # push + create DRAFT PR via gh (Option A integrated)
#   git diff origin/main..HEAD | git ai-pr --no-commits --no-diff
#
# Env:
#   CODEX_CMD      (default: codex)      - command that reads prompt from stdin and prints response
#   CODEX_ARGS     (default: empty)      - extra args passed to CODEX_CMD
#   AI_MAX_CHARS   (default: 120000)     - truncation guardrail for diff/piped input
#   AI_PR_REMOTE   (default: origin)     - git remote to push to when creating PR
#   AI_PR_BASE     (optional)            - base branch name override (e.g. main). If not set, inferred.
#   AI_PR_PUSH     (default: 1)          - set to 0 to skip push during --create-draft
#
# Notes:
# - --create-draft uses `gh pr create --draft --fill` (no reviewers).
# - Title/body are filled from commits by gh; the Codex output remains printed to stdout for your use.

CODEX_CMD="${CODEX_CMD:-codex}"
# Default to non-interactive stdin mode that works with pipes/subshells
CODEX_ARGS="${CODEX_ARGS:-exec --color never -}"
AI_MAX_CHARS="${AI_MAX_CHARS:-120000}"
AI_PR_REMOTE="${AI_PR_REMOTE:-origin}"
AI_PR_BASE="${AI_PR_BASE:-}"
AI_PR_PUSH="${AI_PR_PUSH:-1}"

usage() {
  cat <<EOF
git ai-pr [--base <ref>] [--no-diff] [--no-commits] [--full] [--create-draft] [--no-push]

Generates a DevSecOps-minded squash commit message for current branch vs base.
Optionally creates a GitHub PR as a draft using gh (Option A).

Options:
  --base <ref>       Base ref to compare against (default: tries origin/HEAD -> origin/main -> origin/master -> main)
  --no-diff          Do not include diff (useful if piping your own content)
  --no-commits       Do not include commit list
  --full             Include extra DevSecOps checklist questions in the prompt
  --create-draft     Push branch (unless --no-push) and create a DRAFT PR via gh using --fill
  --no-push          When used with --create-draft, skips git push (assumes already pushed)
  -h, --help         Show help

Examples:
  git ai-pr
  git ai-pr --create-draft
  git ai-pr --base origin/main --create-draft
  git diff origin/main..HEAD | git ai-pr --no-commits --no-diff
EOF
}

pick_default_base_ref() {
  # Prefer origin/HEAD symbolic ref (e.g., origin/main)
  if git symbolic-ref -q --short refs/remotes/origin/HEAD >/dev/null 2>&1; then
    git symbolic-ref -q --short refs/remotes/origin/HEAD | sed 's#^origin/##' | awk '{print "origin/"$0}'
    return
  fi
  # Common fallbacks
  if git show-ref -q --verify refs/remotes/origin/main; then echo "origin/main"; return; fi
  if git show-ref -q --verify refs/remotes/origin/master; then echo "origin/master"; return; fi
  echo "main"
}

# Convert a base ref (origin/main) to a base branch name (main) for gh
base_ref_to_branch() {
  local ref="$1"
  case "$ref" in
    origin/*) echo "${ref#origin/}" ;;
    */*)      echo "${ref##*/}" ;;
    *)        echo "$ref" ;;
  esac
}

truncate() {
  local s="$1"
  if (( ${#s} > AI_MAX_CHARS )); then
    printf "%s\n\n[TRUNCATED to %s chars]\n" "${s:0:AI_MAX_CHARS}" "$AI_MAX_CHARS"
  else
    printf "%s\n" "$s"
  fi
}

BASE_REF=""
INCLUDE_DIFF=1
INCLUDE_COMMITS=1
FULL=0
JSON_OUT=0
CREATE_DRAFT=0
NO_PUSH=0

while (( $# > 0 )); do
  case "$1" in
    --base) BASE_REF="${2:-}"; shift 2 ;;
    --no-diff) INCLUDE_DIFF=0; shift ;;
    --no-commits) INCLUDE_COMMITS=0; shift ;;
    --full) FULL=1; shift ;;
    --json) JSON_OUT=1; shift ;;
    --create-draft) CREATE_DRAFT=1; shift ;;
    --no-push) NO_PUSH=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) die "Unknown arg: $1" ;;
  esac
done

git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not in a git repo."

if [[ -z "$BASE_REF" ]]; then
  BASE_REF="$(pick_default_base_ref)"
fi

# Always require jq (per your request)
require_cmd jq
require_cmd "$CODEX_CMD"

PIPED_INPUT=""
if [[ ! -t 0 ]]; then
  PIPED_INPUT="$(cat)"
fi

COMMITS=""
DIFF=""

if (( INCLUDE_COMMITS == 1 )); then
  COMMITS="$(git log --oneline --reverse "${BASE_REF}..HEAD" 2>/dev/null || true)"
fi

if (( INCLUDE_DIFF == 1 )); then
  if [[ -n "$PIPED_INPUT" ]]; then
    DIFF="$PIPED_INPUT"
  else
    DIFF="$(git diff --patch "${BASE_REF}..HEAD" 2>/dev/null || true)"
  fi
else
  DIFF="$PIPED_INPUT"
fi

STATUS="$(git status --porcelain=v1 2>/dev/null || true)"
CHANGED_FILES="$(git diff --name-status "${BASE_REF}..HEAD" 2>/dev/null || true)"
SUBMODULES="$(git diff --submodule "${BASE_REF}..HEAD" 2>/dev/null || true)"

POTENTIAL_SECRETS="$( (git diff "${BASE_REF}..HEAD" | grep -E -i 'apikey|api_key|secret|token|password|private_key|BEGIN (RSA|OPENSSH) PRIVATE KEY' || true) | head -n 20 )"
PERMISSIONS_HINTS="$( (git diff "${BASE_REF}..HEAD" | grep -E -i 'iam:|policy|role|rbac|clusterrole|serviceaccount|assumeRole|oidc|permissions' || true) | head -n 40 )"

EXTRA_CHECKLIST=""
if (( FULL == 1 )); then
  EXTRA_CHECKLIST=$'
Extra DevSecOps checklist (answer only when evidence exists in the diff):
- AuthN/AuthZ: any permission boundary changes? least privilege preserved?
- Secrets: any new secrets handling? ensure no hardcoded credentials.
- Supply chain: dependency bumps? lockfile changes? verify provenance?
- CI/CD: pipeline changes? new third-party actions? pin versions/SHAs?
- IaC: Terraform/K8s changes? drift/rollback plan? blast radius?
- Logging/Telemetry: PII risk? log levels? audit trails?
- Network: ingress/egress rules? ports exposed? TLS changes?
- Backward compatibility: migrations? feature flags? safe rollout?
'
fi

OUTPUT_FORMAT_TEXT=$'Output format:\n- First line: Conventional Commit subject\n- Blank line\n- Bullets summarizing changes\n- Blank line\n- "Security/DevSecOps Impact:" section (bullets)\n- "Testing:" section (bullets)\n'

OUTPUT_FORMAT_JSON=$'Output format (JSON only, no markdown, no commentary, no code fences):\n{\n  "subject": "type(scope): subject <= 72 chars",\n  "summary_bullets": ["..."],\n  "security_devsecops_impact": ["..."],\n  "testing": ["..."]\n}\nRules:\n- JSON must be valid.\n- Arrays must contain strings only.\n- Do not invent changes not present in commits/diff.\n- If you cannot substantiate a security claim from the diff, write \"No evidence in diff\".\n'

PROMPT="$(cat <<EOF
Task:
Create a single high-quality *squash merge commit message* for this PR/branch with a DevSecOps mindset.

Context:
- Repo: $(basename "$(git rev-parse --show-toplevel)")
- Branch: $(git rev-parse --abbrev-ref HEAD)
- Base: ${BASE_REF}

Core requirements:
- Use Conventional Commits: type(scope): subject
- Subject <= 72 chars (no trailing period)
- Body: bullet summary of meaningful changes (group by area if helpful)
- Include sections:
  - Security/DevSecOps Impact:
  - Testing:
- Do not invent changes not present in commits/diff
- If you cannot substantiate a security claim from the diff, say "No evidence in diff" rather than guessing

Working Tree Status:
${STATUS:-<clean>}

Changed files:
${CHANGED_FILES:-<none>}

Submodule hints:
${SUBMODULES:-<none>}

Potential secret matches:
${POTENTIAL_SECRETS:-<none>}

Permissions/IAM/RBAC hints:
${PERMISSIONS_HINTS:-<none>}

Commit list:
${COMMITS:-<none>}

Diff or piped input:
$(truncate "${DIFF:-<none>}")

${EXTRA_CHECKLIST}
$(
  if (( JSON_OUT == 1 )); then
    printf "%s" "$OUTPUT_FORMAT_JSON"
  else
    printf "%s" "$OUTPUT_FORMAT_TEXT"
  fi
)
EOF
)"

# shellcheck disable=SC2086
RAW_OUTPUT="$(printf "%s" "$PROMPT" | "$CODEX_CMD" $CODEX_ARGS)"

# Drop everything from first "tokens used" line onward.
# Also drop "Rollback/Operational Notes:" section if emitted anyway.
CLEAN_OUTPUT="$(
  awk '
    BEGIN {drop_tokens=0; drop_rollback=0}
    /^[[:space:]]*tokens used[[:space:]]*$/ {drop_tokens=1}
    /^[[:space:]]*Rollback\/Operational Notes:[[:space:]]*$/ {drop_rollback=1}
    (drop_tokens==0 && drop_rollback==0) {print}
  ' <<<"$RAW_OUTPUT"
)"

# Trim trailing whitespace-only lines
CLEAN_OUTPUT="$(
  perl -0777 -pe 's/\s+\z/\n/s' <<<"$CLEAN_OUTPUT"
)"

if (( JSON_OUT == 1 )); then
  printf "%s" "$CLEAN_OUTPUT" | jq -e . >/dev/null 2>&1 || {
    echo "ERROR: Codex output was not valid JSON." >&2
    echo "----- BEGIN RAW OUTPUT -----" >&2
    printf "%s\n" "$RAW_OUTPUT" >&2
    echo "----- END RAW OUTPUT -----" >&2
    exit 1
  }
fi

printf "%s\n" "$CLEAN_OUTPUT"

if (( CREATE_DRAFT == 1 )); then
  require_cmd gh

  GH_BASE="${AI_PR_BASE:-$(base_ref_to_branch "$BASE_REF")}"
  HEAD_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
  [[ "$HEAD_BRANCH" != "HEAD" ]] || die "Detached HEAD. Check out a branch before creating a PR."

  if (( NO_PUSH == 0 )) && (( AI_PR_PUSH == 1 )); then
    if ! git rev-parse --abbrev-ref --symbolic-full-name "@{u}" >/dev/null 2>&1; then
      git push -u "$AI_PR_REMOTE" HEAD
    else
      git push "$AI_PR_REMOTE" HEAD
    fi
  fi

  gh pr create --draft --base "$GH_BASE" --fill
fi
