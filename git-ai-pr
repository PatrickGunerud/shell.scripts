#!/usr/bin/env bash
set -euo pipefail

# git-ai-pr: DevSecOps-minded squash PR summary + (optional) auto-create GitHub PR as DRAFT via gh
#
# Pattern 3 wrapper:
# - If stdin is piped, uses that as diff/input body (instead of collecting diff)
# - Otherwise collects commits + diff vs base
#
# Usage:
#   git ai-pr
#   git ai-pr --base origin/main
#   git ai-pr --create-draft              # push + create DRAFT PR via gh (Option A integrated)
#   git diff origin/main..HEAD | git ai-pr --no-commits --no-diff
#
# Env:
#   CODEX_CMD      (default: codex)      - command that reads prompt from stdin and prints response
#   CODEX_ARGS     (default: empty)      - extra args passed to CODEX_CMD
#   AI_MAX_CHARS   (default: 120000)     - truncation guardrail for diff/piped input
#   AI_PR_REMOTE   (default: origin)     - git remote to push to when creating PR
#   AI_PR_BASE     (optional)            - base branch name override (e.g. main). If not set, inferred.
#   AI_PR_PUSH     (default: 1)          - set to 0 to skip push during --create-draft
#
# Notes:
# - --create-draft uses `gh pr create --draft --fill` (no reviewers).
# - Title/body are filled from commits by gh; the Codex output remains printed to stdout for your use.

CODEX_CMD="${CODEX_CMD:-codex}"
# Default to non-interactive stdin mode that works with pipes/subshells
CODEX_ARGS="${CODEX_ARGS:-exec --color never -}"
AI_MAX_CHARS="${AI_MAX_CHARS:-120000}"
AI_PR_REMOTE="${AI_PR_REMOTE:-origin}"
AI_PR_BASE="${AI_PR_BASE:-}"
AI_PR_PUSH="${AI_PR_PUSH:-1}"

usage() {
  cat <<EOF
git ai-pr [--base <ref>] [--no-diff] [--no-commits] [--full] [--create-draft] [--no-push]

Generates a DevSecOps-minded squash commit message for current branch vs base.
Optionally creates a GitHub PR as a draft using gh (Option A).

Options:
  --base <ref>       Base ref to compare against (default: tries origin/HEAD -> origin/main -> origin/master -> main)
  --no-diff          Do not include diff (useful if piping your own content)
  --no-commits       Do not include commit list
  --full             Include extra DevSecOps checklist questions in the prompt
  --create-draft     Push branch (unless --no-push) and create a DRAFT PR via gh using --fill
  --no-push          When used with --create-draft, skips git push (assumes already pushed)
  -h, --help         Show help

Examples:
  git ai-pr
  git ai-pr --create-draft
  git ai-pr --base origin/main --create-draft
  git diff origin/main..HEAD | git ai-pr --no-commits --no-diff
EOF
}

pick_default_base_ref() {
  # Prefer origin/HEAD symbolic ref (e.g., origin/main)
  if git symbolic-ref -q --short refs/remotes/origin/HEAD >/dev/null 2>&1; then
    git symbolic-ref -q --short refs/remotes/origin/HEAD | sed 's#^origin/##' | awk '{print "origin/"$0}'
    return
  fi
  # Common fallbacks
  if git show-ref -q --verify refs/remotes/origin/main; then echo "origin/main"; return; fi
  if git show-ref -q --verify refs/remotes/origin/master; then echo "origin/master"; return; fi
  echo "main"
}

# Convert a base ref (origin/main) to a base branch name (main) for gh
base_ref_to_branch() {
  local ref="$1"
  case "$ref" in
    origin/*) echo "${ref#origin/}" ;;
    */*)      echo "${ref##*/}" ;;
    *)        echo "$ref" ;;
  esac
}

truncate() {
  local s="$1"
  if (( ${#s} > AI_MAX_CHARS )); then
    printf "%s\n\n[TRUNCATED to %s chars]\n" "${s:0:AI_MAX_CHARS}" "$AI_MAX_CHARS"
  else
    printf "%s\n" "$s"
  fi
}

BASE_REF=""
INCLUDE_DIFF=1
INCLUDE_COMMITS=1
FULL=0
CREATE_DRAFT=0
NO_PUSH=0

while (( $# > 0 )); do
  case "$1" in
    --base) BASE_REF="${2:-}"; shift 2 ;;
    --no-diff) INCLUDE_DIFF=0; shift ;;
    --no-commits) INCLUDE_COMMITS=0; shift ;;
    --full) FULL=1; shift ;;
    --create-draft) CREATE_DRAFT=1; shift ;;
    --no-push) NO_PUSH=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) echo "Unknown arg: $1" >&2; usage; exit 2 ;;
  esac
done

# Ensure we are in a git work tree
git rev-parse --is-inside-work-tree >/dev/null 2>&1 || { echo "ERROR: Not in a git repo." >&2; exit 1; }

if [[ -z "$BASE_REF" ]]; then
  BASE_REF="$(pick_default_base_ref)"
fi

# Pattern 3: piped input becomes the diff/input body
PIPED_INPUT=""
if [[ ! -t 0 ]]; then
  PIPED_INPUT="$(cat)"
fi

COMMITS=""
DIFF=""

if (( INCLUDE_COMMITS == 1 )); then
  COMMITS="$(git log --oneline --reverse "${BASE_REF}..HEAD" 2>/dev/null || true)"
fi

if (( INCLUDE_DIFF == 1 )); then
  if [[ -n "$PIPED_INPUT" ]]; then
    DIFF="$PIPED_INPUT"
  else
    DIFF="$(git diff --patch "${BASE_REF}..HEAD" 2>/dev/null || true)"
  fi
else
  DIFF="$PIPED_INPUT"
fi

STATUS="$(git status --porcelain=v1 2>/dev/null || true)"

# Helpful metadata for security-minded summaries
CHANGED_FILES="$(git diff --name-status "${BASE_REF}..HEAD" 2>/dev/null || true)"
SUBMODULES="$(git diff --submodule "${BASE_REF}..HEAD" 2>/dev/null || true)"

# Best-effort hints (non-fatal)
POTENTIAL_SECRETS="$( (git diff "${BASE_REF}..HEAD" | grep -E -i 'apikey|api_key|secret|token|password|private_key|BEGIN (RSA|OPENSSH) PRIVATE KEY' || true) | head -n 20 )"
PERMISSIONS_HINTS="$( (git diff "${BASE_REF}..HEAD" | grep -E -i 'iam:|policy|role|rbac|clusterrole|serviceaccount|assumeRole|oidc|permissions' || true) | head -n 40 )"

EXTRA_CHECKLIST=""
if (( FULL == 1 )); then
  EXTRA_CHECKLIST=$'
Extra DevSecOps checklist (answer only when evidence exists in the diff):
- AuthN/AuthZ: any permission boundary changes? least privilege preserved?
- Secrets: any new secrets handling? ensure no hardcoded credentials.
- Supply chain: dependency bumps? lockfile changes? verify provenance?
- CI/CD: pipeline changes? new third-party actions? pin versions/SHAs?
- IaC: Terraform/K8s changes? drift/rollback plan? blast radius?
- Logging/Telemetry: PII risk? log levels? audit trails?
- Network: ingress/egress rules? ports exposed? TLS changes?
- Backward compatibility: migrations? feature flags? safe rollout?
'
fi

PROMPT="$(cat <<EOF
Task:
Create a single high-quality *squash merge commit message* for this PR/branch with a DevSecOps mindset.

Context:
- Repo: $(basename "$(git rev-parse --show-toplevel)")
- Branch: $(git rev-parse --abbrev-ref HEAD)
- Base: ${BASE_REF}

Core requirements:
- Use Conventional Commits: type(scope): subject
- Subject <= 72 chars (no trailing period)
- Body: bullet summary of meaningful changes (group by area if helpful)
- Include sections:
  - Security/DevSecOps Impact:
  - Testing:
  - Rollback/Operational Notes:
- Do not invent changes not present in commits/diff
- If you cannot substantiate a security claim from the diff, say "No evidence in diff" rather than guessing

DevSecOps guidance:
- Call out changes affecting: authn/authz, secrets, CI/CD, dependencies, IaC, network exposure, logging/PII, encryption/TLS, permissions.
- If dependencies or CI actions changed, mention whether versions are pinned and what risk remains.
- If IaC / config changes, mention blast radius and rollout/rollback considerations.
- If anything looks like a secret, flag it and recommend verification steps.

Working Tree Status (PRs should usually be clean):
${STATUS:-<clean>}

Changed files (name-status):
${CHANGED_FILES:-<none>}

Submodule hints (if any):
${SUBMODULES:-<none>}

Potential secret matches (best-effort, may be false positives):
${POTENTIAL_SECRETS:-<none detected in diff snippet>}

Permissions/IAM/RBAC hints (best-effort):
${PERMISSIONS_HINTS:-<none detected in diff snippet>}

Commit list (base..HEAD):
${COMMITS:-<none provided>}

Unified diff (base..HEAD) or piped input:
$(truncate "${DIFF:-<none provided>}")

${EXTRA_CHECKLIST}
Output format:
- First line: Conventional Commit subject
- Blank line
- Bullets summarizing changes
- Blank line
- "Security/DevSecOps Impact:" section (bullets)
- "Testing:" section (bullets)
- "Rollback/Operational Notes:" section (bullets)
EOF
)"

# 1) Always produce the Codex text (or prompt)
if command -v "$CODEX_CMD" >/dev/null 2>&1; then
  # shellcheck disable=SC2086
  CODEX_OUTPUT="$(printf "%s" "$PROMPT" | "$CODEX_CMD" $CODEX_ARGS)"
  printf "%s\n" "$CODEX_OUTPUT"
else
  echo "NOTE: \$CODEX_CMD ('$CODEX_CMD') not found. Printing prompt instead." >&2
  echo "----- BEGIN PROMPT -----"
  printf "%s\n" "$PROMPT"
  echo "----- END PROMPT -----"
  exit 0
fi

# 2) Option A integrated: create a draft PR via gh using --fill (no reviewer)
if (( CREATE_DRAFT == 1 )); then
  command -v gh >/dev/null 2>&1 || { echo "ERROR: gh not found. Install GitHub CLI first." >&2; exit 1; }

  # Determine base branch for gh
  GH_BASE="${AI_PR_BASE:-$(base_ref_to_branch "$BASE_REF")}"

  # Ensure branch name is sane
  HEAD_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
  if [[ "$HEAD_BRANCH" == "HEAD" ]]; then
    echo "ERROR: Detached HEAD. Check out a branch before creating a PR." >&2
    exit 1
  fi

  # Push branch unless skipped
  if (( NO_PUSH == 0 )) && (( AI_PR_PUSH == 1 )); then
    # If no upstream exists, set it. Otherwise push normally.
    if ! git rev-parse --abbrev-ref --symbolic-full-name "@{u}" >/dev/null 2>&1; then
      git push -u "$AI_PR_REMOTE" HEAD
    else
      git push "$AI_PR_REMOTE" HEAD
    fi
  fi

  # Create draft PR. Use --fill so gh generates title/body from commits.
  # No reviewers added.
  gh pr create --draft --base "$GH_BASE" --fill

  # Note: gh prints the PR URL on success.
fi

