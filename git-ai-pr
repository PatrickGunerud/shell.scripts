#!/usr/bin/env bash
set -euo pipefail

# git-ai-pr: DevSecOps-minded squash PR summary + (optional) auto-create GitHub PR as DRAFT via gh
#
# Model backend selection:
#   AI_BACKEND=codex|claude   (default: codex)
#
# Backend env:
#   Codex:
#     CODEX_CMD   (default: codex)
#     CODEX_ARGS  (default: exec --color never -)
#   Claude (Anthropic CLI):
#     CLAUDE_CMD  (default: claude)
#     CLAUDE_ARGS (default: -p)   # reads prompt from stdin; prints completion to stdout

source "$(dirname "$0")/lib/git-ai-common.sh"

AI_PR_REMOTE="${AI_PR_REMOTE:-origin}"
AI_PR_BASE="${AI_PR_BASE:-}"
AI_PR_PUSH="${AI_PR_PUSH:-1}"

usage() {
  cat <<EOF
git ai-pr [--base <ref>] [--no-diff] [--no-commits] [--full] [--json] [--create-draft] [--no-push]

Backends:
  AI_BACKEND=codex   Uses: \$CODEX_CMD \$CODEX_ARGS
  AI_BACKEND=claude  Uses: \$CLAUDE_CMD \$CLAUDE_ARGS

Options:
  --json             Request JSON output (requires jq; validates output)
EOF
}

pick_default_base_ref() {
  if git symbolic-ref -q --short refs/remotes/origin/HEAD >/dev/null 2>&1; then
    git symbolic-ref -q --short refs/remotes/origin/HEAD | sed 's#^origin/##' | awk '{print "origin/"$0}'
    return
  fi
  if git show-ref -q --verify refs/remotes/origin/main; then echo "origin/main"; return; fi
  if git show-ref -q --verify refs/remotes/origin/master; then echo "origin/master"; return; fi
  echo "main"
}

base_ref_to_branch() {
  local ref="$1"
  case "$ref" in
    origin/*) echo "${ref#origin/}" ;;
    */*)      echo "${ref##*/}" ;;
    *)        echo "$ref" ;;
  esac
}

BASE_REF=""
INCLUDE_DIFF=1
INCLUDE_COMMITS=1
FULL=0
JSON_OUT=0
CREATE_DRAFT=0
NO_PUSH=0

while (( $# > 0 )); do
  case "$1" in
    --base) BASE_REF="${2:-}"; shift 2 ;;
    --no-diff) INCLUDE_DIFF=0; shift ;;
    --no-commits) INCLUDE_COMMITS=0; shift ;;
    --full) FULL=1; shift ;;
    --json) JSON_OUT=1; shift ;;
    --create-draft) CREATE_DRAFT=1; shift ;;
    --no-push) NO_PUSH=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) die "Unknown arg: $1" ;;
  esac
done

git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not in a git repo."

if [[ -z "$BASE_REF" ]]; then
  BASE_REF="$(pick_default_base_ref)"
fi

preflight_check git jq grep head perl awk

PIPED_INPUT=""
if [[ ! -t 0 ]]; then
  PIPED_INPUT="$(cat)"
fi

COMMITS=""
DIFF=""

if (( INCLUDE_COMMITS == 1 )); then
  COMMITS="$(git log --oneline --reverse "${BASE_REF}..HEAD" 2>/dev/null || true)"
fi

if (( INCLUDE_DIFF == 1 )); then
  if [[ -n "$PIPED_INPUT" ]]; then
    DIFF="$PIPED_INPUT"
  else
    DIFF="$(git diff --patch "${BASE_REF}..HEAD" 2>/dev/null || true)"
  fi
else
  DIFF="$PIPED_INPUT"
fi

STATUS="$(git status --porcelain=v1 2>/dev/null || true)"
CHANGED_FILES="$(git diff --name-status "${BASE_REF}..HEAD" 2>/dev/null || true)"
SUBMODULES="$(git diff --submodule "${BASE_REF}..HEAD" 2>/dev/null || true)"

POTENTIAL_SECRETS="$( (git diff "${BASE_REF}..HEAD" | grep -E -i 'apikey|api_key|secret|token|password|private_key|BEGIN (RSA|OPENSSH) PRIVATE KEY' || true) | head -n 20 )"
PERMISSIONS_HINTS="$( (git diff "${BASE_REF}..HEAD" | grep -E -i 'iam:|policy|role|rbac|clusterrole|serviceaccount|assumeRole|oidc|permissions' || true) | head -n 40 )"

EXTRA_CHECKLIST=""
if (( FULL == 1 )); then
  EXTRA_CHECKLIST=$'
Extra DevSecOps checklist (answer only when evidence exists in the diff):
- AuthN/AuthZ: any permission boundary changes? least privilege preserved?
- Secrets: any new secrets handling? ensure no hardcoded credentials.
- Supply chain: dependency bumps? lockfile changes? verify provenance?
- CI/CD: pipeline changes? new third-party actions? pin versions/SHAs?
- IaC: Terraform/K8s changes? drift/rollback plan? blast radius?
- Logging/Telemetry: PII risk? log levels? audit trails?
- Network: ingress/egress rules? ports exposed? TLS changes?
- Backward compatibility: migrations? feature flags? safe rollout?
'
fi

OUTPUT_FORMAT_TEXT=$'Output format:\n- First line: Conventional Commit subject\n- Blank line\n- Bullets summarizing changes\n- Blank line\n- "Security/DevSecOps Impact:" section (bullets)\n- "Testing:" section (bullets)\n'

OUTPUT_FORMAT_JSON=$'Output format (JSON only, no markdown, no commentary, no code fences):\n{\n  "subject": "type(scope): subject <= 72 chars",\n  "summary_bullets": ["..."],\n  "security_devsecops_impact": ["..."],\n  "testing": ["..."]\n}\nRules:\n- JSON must be valid.\n- Arrays must contain strings only.\n- Do not invent changes not present in commits/diff.\n- If you cannot substantiate a security claim from the diff, write \"No evidence in diff\".\n'

PROMPT="$(cat <<EOF
Task:
Create a single high-quality *squash merge commit message* for this PR/branch with a DevSecOps mindset.

Context:
- Repo: $(basename "$(git rev-parse --show-toplevel)")
- Branch: $(git rev-parse --abbrev-ref HEAD)
- Base: ${BASE_REF}

Core requirements:
- Use Conventional Commits: type(scope): subject
- Subject <= 72 chars (no trailing period)
- Body: bullet summary of meaningful changes (group by area if helpful)
- Include sections:
  - Security/DevSecOps Impact:
  - Testing:
- Do not invent changes not present in commits/diff
- If you cannot substantiate a security claim from the diff, say "No evidence in diff" rather than guessing

Working Tree Status:
${STATUS:-<clean>}

Changed files:
${CHANGED_FILES:-<none>}

Submodule hints:
${SUBMODULES:-<none>}

Potential secret matches:
${POTENTIAL_SECRETS:-<none>}

Permissions/IAM/RBAC hints:
${PERMISSIONS_HINTS:-<none>}

Commit list:
${COMMITS:-<none>}

Diff or piped input:
$(truncate "${DIFF:-<none>}")

${EXTRA_CHECKLIST}
$(
  if (( JSON_OUT == 1 )); then
    printf "%s" "$OUTPUT_FORMAT_JSON"
  else
    printf "%s" "$OUTPUT_FORMAT_TEXT"
  fi
)
EOF
)"

RAW_OUTPUT="$(run_ai "$PROMPT")"
CLEAN_OUTPUT="$(clean_ai_output "$RAW_OUTPUT")"

if (( JSON_OUT == 1 )); then
  printf "%s" "$CLEAN_OUTPUT" | jq -e . >/dev/null 2>&1 || {
    echo "ERROR: AI output was not valid JSON." >&2
    echo "----- BEGIN RAW OUTPUT -----" >&2
    printf "%s\n" "$RAW_OUTPUT" >&2
    echo "----- END RAW OUTPUT -----" >&2
    exit 1
  }
fi

printf "%s\n" "$CLEAN_OUTPUT"

if (( CREATE_DRAFT == 1 )); then
  require_cmd gh

  GH_BASE="${AI_PR_BASE:-$(base_ref_to_branch "$BASE_REF")}"
  HEAD_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
  [[ "$HEAD_BRANCH" != "HEAD" ]] || die "Detached HEAD. Check out a branch before creating a PR."

  if (( NO_PUSH == 0 )) && (( AI_PR_PUSH == 1 )); then
    if ! git rev-parse --abbrev-ref --symbolic-full-name "@{u}" >/dev/null 2>&1; then
      git push -u "$AI_PR_REMOTE" HEAD
    else
      git push "$AI_PR_REMOTE" HEAD
    fi
  fi

  gh pr create --draft --base "$GH_BASE" --fill
fi
